from cozmo.util import Pose
from cv2 import Rodrigues
from numpy import matrix
from pdb import set_trace



from .nodes import *
from .transitions import *
from .transform import wrap_angle
from .pilot import PilotToPose, PilotCheckStart

from math import sin, cos, atan2, pi, sqrt

class GoToWall(StateNode):

    def __init__(self, wall=None):
        self.object = wall
        super().__init__()

    def pick_side(self, dist, door=0):
        wall = self.object
        wobj = self.robot.world.world_map.objects[wall]
        x = wobj.x 
        y = wobj.y
        ang = wobj.theta
        rx = self.robot.world.particle_filter.pose[0]
        ry = self.robot.world.particle_filter.pose[1]

        side1 = (x + cos(ang) * dist - sin(ang)*( wobj.doorways[door][0] - wobj.length/2 ), y + sin(ang) * dist - cos(ang)*( wobj.doorways[door][0] - wobj.length/2 ), ang + pi)
        side2 = (x - cos(ang) * dist - sin(ang)*( wobj.doorways[door][0] - wobj.length/2 ), y - sin(ang) * dist - cos(ang)*( wobj.doorways[door][0] - wobj.length/2 ), ang)
        sides = [side1, side2]
        sorted_sides = sorted(sides, key=lambda pt: (pt[0]-rx)**2 + (pt[1]-ry)**2)
        return sorted_sides[0]

    def locate_marker(self, marker):
        if marker not in self.robot.world.aruco.seen_marker_ids:
            print("FAIL")
        else:
            mobj = self.robot.world.aruco.seen_marker_objects[marker]
            return mobj.opencv_translation[0]


    class GoToSide(PilotToPose):
        def __init__(self):
            super().__init__(None)

        def start(self, event=None):
            wall = self.parent.object
            print('Selected wall',self.robot.world.world_map.objects[wall])
            (x, y, theta) = self.parent.pick_side(150,1)
            self.target_pose = Pose(x, y, self.robot.pose.position.z,
                                    angle_z=Angle(radians = wrap_angle(theta)))
            print('Traveling to',self.target_pose)
            super().start(event)

    class ReportPosition(StateNode):
        def start(self,event=None):
            super().start(event)
            wall = self.parent.object
            wobj = self.robot.world.world_map.objects[wall]
            cx = wobj.x
            cy = wobj.y
            rx = self.robot.pose.position.x
            ry = self.robot.pose.position.y
            dx = cx - rx
            dy = cy - ry
            dist = math.sqrt(dx*dx + dy*dy)
            bearing = wrap_angle(atan2(dy,dx) - self.robot.pose.rotation.angle_z.radians) * 180/pi
            print('wall at (%5.1f,%5.1f)  robot at (%5.1f,%5.1f)  dist=%5.1f  brg=%5.1f' %
                  (cx, cy, rx, ry, dist, bearing))


    class FindDoor(SetHeadAngle):
        def __init__(self):
            self.angle =  Angle(degrees = 24)
            super().__init__()

        def start(self, event=None):
            if self.running: return
            wall = self.parent.object
            if 11 not in self.robot.world.aruco.seen_marker_ids:
                print('** Could not see the door.', self.angle)
                self.angle = Angle(degrees = self.angle.degrees + 5 )
                super().start(event)
            else:
                print('Found Door')
                super().start(event)


    class VerifyDoor(StateNode):
        def __init__(self):
            super().__init__()
        def start(self,event=None):
            super().start(event)
            set_trace()
            if 11 in self.robot.world.aruco.seen_marker_ids:
                print("YES")
                self.post_success()
            else:
                print("NO")
                self.post_failure()


    class AlightwithDoor(PilotToPose):
        def __init__(self, offset=0, check_vis=False):
            self.offset = offset
            self.check_vis = check_vis
            super().__init__()

        def start(self, event=None):
            if self.running: return
            wall = self.parent.object
            print("Aligning")
            if self.check_vis and 11 not in self.robot.world.aruco.seen_marker_ids:
                print('** Could not see the door.')
                self.angle = 0 # Angle(0)
                super().start(event)
                self.post_failure()
            else:
                
                dy = self.parent.locate_marker(11)
                self.target_pose = Pose(self.robot.pose.position.x, self.robot.pose.position.y-dy, self.robot.pose.position.z,
                                        angle_z=self.robot.pose.rotation.angle_z)
                print('Traveling to',self.target_pose)
                super().start(event)


    class ForwardToWall(Forward):
        def __init__(self, offset):
            self.offset = offset
            super().__init__()

        def start(self, event=None):
            if self.running: return
            cube = self.parent.object
            dx = cube.pose.position.x - self.robot.pose.position.x
            dy = cube.pose.position.y - self.robot.pose.position.y
            self.distance = Distance(sqrt(dx*dx + dy*dy) - self.offset)
            super().start(event)

    $setup{
        droplift: SetLiftHeight(0) =T(0.5)=> lookup    # time for vision to set up world map

        check_start: PilotCheckStart()
        check_start =S=> go_side
        check_start =F=> Forward(-80) =C=> check_start

        go_side: self.GoToSide()
        go_side =F=> ParentFails()
        go_side =C=> self.ReportPosition()
            =T(0.5)=> self.ReportPosition()
            =T(0.5)=> self.ReportPosition()
            =N=> lookup

        lookup:  SetHeadAngle(24) =T(2)=> find

        find: self.FindDoor() =C=> verify

        verify: self.VerifyDoor()
        verify =S=> face_wall
        verify =F=> find

        face_wall: self.AlightwithDoor(0,True) =C=>
            self.ReportPosition() =T(0.5)=> self.ReportPosition()
            =T(0.5)=> self.ReportPosition()=N=> end

        end: ParentCompletes()
    }



